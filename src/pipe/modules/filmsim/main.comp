#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  float radius;
  float strength;
} params;


// XXX TODO: we're never writing to aux.y (i.e. crystal count stays constant). leave away?
layout( // input aux channels (dc, ac, cr, sh)
    set = 1, binding = 0
) uniform sampler2D img_in;

layout( // input blurred developer concentration
    set = 1, binding = 1
) uniform sampler2D img_dev;

layout( // output aux
    set = 1, binding = 2
) uniform writeonly image2D img_out;

void
main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  // we'll read blurred input from a downsampled image, so we want to smooth it during upsampling:
  float dev = texture(img_dev, (ipos+.5)/vec2(imageSize(img_out))).r;
  vec4  aux = texelFetch(img_in, ipos, 0);

  // TODO: optionally (not every iteration)
  // layer mix
  // agitate

  // develop
  // differential crystal radius = developer concentration x silver halide density
  const float crystal_growth = 1.0;
  const float dt = 1.0;
  const float dcrystalrad = dev * aux.w * crystal_growth * dt;

  // change in crystal volume = change in radius x radius^2 * active crystals
  // XXX why ^2 i.e. surface and not ^3 i.e. volume?
  const float dcrystalvol = dcrystalrad * aux.z*aux.z * aux.y;

  // grow crystal radius
  aux.z += dcrystalrad;

  // consume developer
  // XXX also depends on layer thickness?  float dcc = 2.0*developerConsumptionConst / ( activeLayerThickness*3.0 );
  const float dcc = 8.0; // developer consumption constant
  aux.x = max(0.0, dev - dcc * dcrystalvol);

  // consume silver halide
  const float shcc = 1.0; // silver halide consumption constant 
  aux.w = max(0.0, aux.w - shcc * dcrystalvol);

  imageStore(img_out, ipos, aux);
}
